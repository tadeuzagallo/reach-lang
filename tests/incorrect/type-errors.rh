// RUN: %not %reach | %check

function f(x: Number) -> Number {
    "asd" // CHECK: 4:5: Unification failure: expected `Number` but found `String`
}
g; // CHECK: :6:1: Unknown variable: `g`
f(1,2); // CHECK: 7:1: Argument count mismatch
f("asd"); // CHECK: 8:3: Unification failure: expected `Number` but found `String`

let x = 1;
x(); // CHECK: 11:1: Callee is not a function

function g(x: Number[]) -> Number[] {
    x
}
// TODO: better error message
g([""]) // CHECK-L: 17:4: Unification failure: expected `Number` but found `String`

function f(x: <String, Number, Number>) -> <String, Number, Number> {
    x
}
f((1, 2, 3)) // CHECK-L: 22:3: Unification failure: expected `String` but found `Number`
f(("1", 2)) // CHECK-L: 23:3: Unification failure: expected `<String, Number, Number>` but found `<String, Number>`

function id(x: Number) -> Number { x }
function f() -> Number { 13 }
let x = { id = f };
inspect(x.id()) // CHECK-L: 28:9: Unification failure: expected `Number` but found `{id: () -> Number}`

// Allow parsing operators that contain unknown tokens (tokens that are not meaningful on their own)
1 #### 2 // CHECK-L: 31:3: Unknown variable: `####`

// record checking
function f(x: {x: String}) -> String { x.x }
f({}) // CHECK-L: 35:3: Unification failure: expected `{x: String}` but found `{:}`

let x : Number = "" // CHECK-L: 37:18: Unification failure: expected `Number` but found `String`
